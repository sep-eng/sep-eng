<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>RECeIPT?</title>
  <style>
    :root { --scale: 4; }
    html, body { height: 100%; margin: 0; background: #000; }
    body { display: grid; place-items: center; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    .wrap { display:flex; flex-direction:column; align-items:center; gap:12px; }
    canvas {
      width: calc(160px * var(--scale));
      height: calc(144px * var(--scale));
      image-rendering: pixelated;
      image-rendering: crisp-edges;
      border-radius: 14px;
      box-shadow: 0 14px 60px rgba(0,0,0,.6);
      background:#000;
      touch-action: none;
      user-select: none;
      -webkit-user-select: none;
    }
    .mini {
      opacity: .7;
      font-size: 12px;
      color: #fff;
      letter-spacing: .08em;
      text-transform: uppercase;
    }
    @media (max-width: 520px){
      :root { --scale: 3; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <canvas id="c" width="160" height="144" aria-label="RECeIPT? game canvas"></canvas>
    <div class="mini">RECeIPT?</div>
  </div>

<script>
(() => {
  const W = 160, H = 144;
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d", { alpha: false });

  ctx.imageSmoothingEnabled = false;

  // Real images (Wikimedia)
  const ASSET_URLS = {
    milkCarton: "https://upload.wikimedia.org/wikipedia/commons/4/4d/Milk_carton_illustration.png",
    milkPhoto:  "https://upload.wikimedia.org/wikipedia/commons/thumb/a/a0/Mleko.jpg/320px-Mleko.jpg",
    receipt:    "https://upload.wikimedia.org/wikipedia/commons/thumb/7/76/ReceiptSwiss.jpg/500px-ReceiptSwiss.jpg",
    printer:    "https://upload.wikimedia.org/wikipedia/commons/thumb/0/08/PICOL_icon_Printer_add.svg/250px-PICOL_icon_Printer_add.svg.png"
  };

  function loadImage(url){
    return new Promise((resolve) => {
      const img = new Image();
      img.crossOrigin = "anonymous";
      img.onload = () => resolve(img);
      img.onerror = () => resolve(null);
      img.src = url;
    });
  }

  const IMG = { milkCarton:null, milkPhoto:null, receipt:null, printer:null };

  // Input
  const keys = new Set();
  let pointerDown = false;
  let pointerX = W/2;

  window.addEventListener("keydown", (e) => {
    keys.add(e.key.toLowerCase());
    if (STATE.mode === "menu" && (e.key === "Enter" || e.key === " ")) startRun();
    if (STATE.mode === "dead" && (e.key === "Enter" || e.key === " ")) { /* ignore */ }
  });
  window.addEventListener("keyup", (e) => keys.delete(e.key.toLowerCase()));

  canvas.addEventListener("pointerdown", (e) => {
    pointerDown = true;
    const p = getPointer(e);
    pointerX = p.x;
    if (STATE.mode === "menu") startRun();
  });
  canvas.addEventListener("pointermove", (e) => {
    if (!pointerDown) return;
    pointerX = getPointer(e).x;
  });
  window.addEventListener("pointerup", () => pointerDown = false);

  function getPointer(e){
    const r = canvas.getBoundingClientRect();
    const sx = W / r.width;
    const sy = H / r.height;
    return {
      x: (e.clientX - r.left) * sx,
      y: (e.clientY - r.top) * sy
    };
  }

  // Game state
  const LEVELS = [
    { goal: 4,  speed: 36, spawn: 0.75, hazard: 0.22, drift: 0.00 },
    { goal: 5,  speed: 42, spawn: 0.80, hazard: 0.25, drift: 0.02 },
    { goal: 6,  speed: 48, spawn: 0.85, hazard: 0.28, drift: 0.03 },
    { goal: 7,  speed: 54, spawn: 0.90, hazard: 0.30, drift: 0.04 },
    { goal: 8,  speed: 60, spawn: 0.98, hazard: 0.33, drift: 0.05 },
    { goal: 9,  speed: 66, spawn: 1.05, hazard: 0.36, drift: 0.06 },
    { goal: 10, speed: 72, spawn: 1.15, hazard: 0.38, drift: 0.07 },
    { goal: 12, speed: 78, spawn: 1.25, hazard: 0.41, drift: 0.08 },
    { goal: 14, speed: 86, spawn: 1.35, hazard: 0.44, drift: 0.09 },
    { goal: 16, speed: 94, spawn: 1.50, hazard: 0.47, drift: 0.10 },
    { goal: 18, speed: 104, spawn: 1.65, hazard: 0.50, drift: 0.11 },
    { goal: 20, speed: 116, spawn: 1.80, hazard: 0.52, drift: 0.12 }
  ];

  const STATE = {
    mode: "loading", // loading | menu | play | dead
    t: 0,
    level: 1,
    collected: 0,
    score: 0,
    spawnAcc: 0,
    flash: 0,
    shake: 0,
    levelBanner: 0,
    lastDt: 1/60
  };

  const player = {
    x: W/2,
    y: H - 22,
    w: 14,
    h: 16,
    speed: 105
  };

  const things = [];     // falling entities
  const particles = [];  // small polish bursts

  function resetRun(){
    STATE.level = 1;
    STATE.collected = 0;
    STATE.score = 0;
    STATE.spawnAcc = 0;
    STATE.flash = 0;
    STATE.shake = 0;
    STATE.levelBanner = 0.9;

    things.length = 0;
    particles.length = 0;

    player.x = W/2;
  }

  function startRun(){
    resetRun();
    STATE.mode = "play";
  }

  function die(){
    STATE.mode = "dead";
    STATE.flash = 0.9;
    STATE.shake = 0.55;

    // restart from level 1 automatically
    setTimeout(() => {
      startRun();
    }, 900);
  }

  function nextLevel(){
    STATE.level = Math.min(STATE.level + 1, LEVELS.length);
    STATE.collected = 0;
    STATE.levelBanner = 0.9;
    STATE.shake = 0.12;
    // clear screen so it feels clean
    things.length = 0;
    particles.length = 0;
  }

  function rand(min, max){ return min + Math.random() * (max - min); }
  function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

  function spawnEntity(){
    const L = LEVELS[STATE.level - 1];
    const x = rand(10, W - 10);
    const isHazard = Math.random() < L.hazard;

    if (isHazard){
      things.push({
        type: "hazard",
        x, y: -12,
        w: 14, h: 14,
        vy: L.speed * rand(0.95, 1.15),
        vx: (Math.random() < 0.5 ? -1 : 1) * L.speed * L.drift * rand(0.5, 1.2),
        spin: rand(-2.5, 2.5),
        a: rand(0, Math.PI*2)
      });
    } else {
      things.push({
        type: "receipt",
        x, y: -18,
        w: 10, h: 14,
        vy: L.speed * rand(0.85, 1.05),
        vx: (Math.random() < 0.5 ? -1 : 1) * L.speed * L.drift * rand(0.4, 1.0),
        wob: rand(1.5, 3.2),
        a: rand(0, Math.PI*2)
      });
    }
  }

  function aabb(ax, ay, aw, ah, bx, by, bw, bh){
    return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
  }

  function burst(x, y, n=10){
    for (let i=0;i<n;i++){
      particles.push({
        x, y,
        vx: rand(-30, 30),
        vy: rand(-40, 10),
        life: rand(0.25, 0.55)
      });
    }
  }

  function update(dt){
    STATE.t += dt;
    STATE.lastDt = dt;

    // menu animation
    if (STATE.mode === "menu") return;

    if (STATE.flash > 0) STATE.flash = Math.max(0, STATE.flash - dt*1.8);
    if (STATE.shake > 0) STATE.shake = Math.max(0, STATE.shake - dt*1.6);
    if (STATE.levelBanner > 0) STATE.levelBanner = Math.max(0, STATE.levelBanner - dt*1.1);

    if (STATE.mode !== "play") return;

    // player movement
    let mv = 0;
    if (keys.has("arrowleft") || keys.has("a")) mv -= 1;
    if (keys.has("arrowright") || keys.has("d")) mv += 1;

    if (pointerDown){
      // follow finger/mouse smoothly
      const dx = pointerX - player.x;
      mv += clamp(dx / 18, -1, 1);
    }

    player.x += mv * player.speed * dt;
    player.x = clamp(player.x, 6, W - 6);

    // spawning
    const L = LEVELS[STATE.level - 1];
    STATE.spawnAcc += dt * L.spawn;
    while (STATE.spawnAcc >= 1){
      STATE.spawnAcc -= 1;
      spawnEntity();
    }

    // update things
    for (let i = things.length - 1; i >= 0; i--){
      const t = things[i];
      t.a = (t.a || 0) + dt * (t.spin || 0);

      if (t.type === "receipt"){
        t.x += t.vx * dt + Math.sin((STATE.t * t.wob) + t.a) * 0.25;
      } else {
        t.x += t.vx * dt;
      }

      t.y += t.vy * dt;

      // bounce side gently
      if (t.x < 4){ t.x = 4; t.vx *= -0.9; }
      if (t.x > W - 4){ t.x = W - 4; t.vx *= -0.9; }

      // collisions (player is centered on x, y is top-left-ish)
      const px = player.x - player.w/2;
      const py = player.y - player.h/2;

      if (aabb(px, py, player.w, player.h, t.x - t.w/2, t.y - t.h/2, t.w, t.h)){
        if (t.type === "hazard"){
          burst(player.x, player.y, 18);
          die();
          return;
        } else {
          burst(t.x, t.y, 10);
          things.splice(i, 1);
          STATE.collected += 1;
          STATE.score += 10;

          if (STATE.collected >= L.goal){
            nextLevel();
          }
          continue;
        }
      }

      // remove offscreen
      if (t.y > H + 22) things.splice(i, 1);
    }

    // particles
    for (let i=particles.length-1;i>=0;i--){
      const p = particles[i];
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.vy += 80 * dt;
      p.life -= dt;
      if (p.life <= 0) particles.splice(i,1);
    }
  }

  function drawBackground(){
    ctx.fillStyle = "#000";
    ctx.fillRect(0,0,W,H);

    // subtle moving banding
    const t = STATE.t;
    ctx.globalAlpha = 0.22;
    for (let i=0;i<6;i++){
      const y = (i*26 + (t*8)) % (H+26) - 26;
      ctx.fillStyle = i % 2 ? "#0a0a0a" : "#050505";
      ctx.fillRect(0, y, W, 18);
    }
    ctx.globalAlpha = 1;

    // milk photo wash
    if (IMG.milkPhoto){
      ctx.globalAlpha = 0.10;
      ctx.drawImage(IMG.milkPhoto, 0, 0, W, H);
      ctx.globalAlpha = 1;
    }
  }

  function drawEntity(t){
    const x = (t.x - t.w/2) | 0;
    const y = (t.y - t.h/2) | 0;

    if (t.type === "hazard"){
      if (IMG.printer){
        ctx.drawImage(IMG.printer, x, y, t.w, t.h);
      } else {
        ctx.fillStyle = "#ef4444";
        ctx.fillRect(x, y, t.w, t.h);
      }
    } else {
      if (IMG.receipt){
        ctx.drawImage(IMG.receipt, x, y, t.w, t.h);
      } else {
        ctx.fillStyle = "#f5f5f5";
        ctx.fillRect(x, y, t.w, t.h);
      }
    }
  }

  function drawPlayer(){
    const x = (player.x - player.w/2) | 0;
    const y = (player.y - player.h/2) | 0;

    if (IMG.milkCarton){
      ctx.drawImage(IMG.milkCarton, x-1, y-2, player.w+2, player.h+4);
    } else {
      ctx.fillStyle = "#fff";
      ctx.fillRect(x, y, player.w, player.h);
    }
  }

  function drawHUD(){
    ctx.fillStyle = "#fff";
    ctx.globalAlpha = 0.85;
    ctx.font = "9px system-ui, sans-serif";
    ctx.fillText(`L${STATE.level}`, 6, 12);
    ctx.fillText(`${STATE.collected}/${LEVELS[STATE.level-1].goal}`, 26, 12);
    ctx.fillText(`${STATE.score}`, W - 6 - ctx.measureText(String(STATE.score)).width, 12);
    ctx.globalAlpha = 1;

    if (STATE.levelBanner > 0){
      const a = Math.min(1, STATE.levelBanner * 1.4);
      ctx.globalAlpha = a;
      ctx.fillStyle = "#000";
      ctx.fillRect(0, (H/2 - 12) | 0, W, 24);
      ctx.fillStyle = "#fff";
      ctx.font = "12px system-ui, sans-serif";
      const txt = `LEVEL ${STATE.level}`;
      const tw = ctx.measureText(txt).width;
      ctx.fillText(txt, ((W - tw)/2) | 0, (H/2 + 4) | 0);
      ctx.globalAlpha = 1;
    }
  }

  function drawMenu(){
    ctx.fillStyle = "#000";
    ctx.fillRect(0,0,W,H);

    if (IMG.milkPhoto){
      ctx.globalAlpha = 0.25;
      ctx.drawImage(IMG.milkPhoto, 0, 0, W, H);
      ctx.globalAlpha = 1;
    }

    // vignette
    ctx.globalAlpha = 0.55;
    ctx.fillStyle = "#000";
    ctx.fillRect(0,0,W, H);
    ctx.globalAlpha = 1;

    // title
    ctx.fillStyle = "#fff";
    ctx.font = "18px system-ui, sans-serif";
    const title = "RECeIPT?";
    const tw = ctx.measureText(title).width;
    ctx.fillText(title, ((W - tw)/2) | 0, 56);

    // start badge
    const bx = (W/2 - 34) | 0;
    const by = 78;
    ctx.fillStyle = "#fff";
    ctx.fillRect(bx, by, 68, 18);
    ctx.fillStyle = "#000";
    ctx.font = "10px system-ui, sans-serif";
    const st = "START";
    const sw = ctx.measureText(st).width;
    ctx.fillText(st, ((W - sw)/2) | 0, by + 12);

    // little scene bits
    if (IMG.milkCarton){
      ctx.drawImage(IMG.milkCarton, 16, 92, 18, 22);
    }
    if (IMG.receipt){
      ctx.drawImage(IMG.receipt, W - 34, 92, 14, 18);
    }
    if (IMG.printer){
      ctx.drawImage(IMG.printer, W/2 - 7, 102, 14, 14);
    }
  }

  function drawDeadFlash(){
    if (STATE.flash <= 0) return;
    ctx.globalAlpha = Math.min(0.55, STATE.flash);
    ctx.fillStyle = "#ef4444";
    ctx.fillRect(0,0,W,H);
    ctx.globalAlpha = 1;
  }

  function drawParticles(){
    if (!particles.length) return;
    ctx.globalAlpha = 0.9;
    for (const p of particles){
      ctx.fillStyle = "#fff";
      ctx.fillRect((p.x|0), (p.y|0), 1, 1);
    }
    ctx.globalAlpha = 1;
  }

  function render(){
    // camera shake
    let ox = 0, oy = 0;
    if (STATE.shake > 0){
      const s = STATE.shake * 4.0;
      ox = (rand(-s, s)) | 0;
      oy = (rand(-s, s)) | 0;
    }

    ctx.save();
    ctx.translate(ox, oy);

    if (STATE.mode === "menu"){
      drawMenu();
      ctx.restore();
      return;
    }

    drawBackground();

    // entities
    for (const t of things) drawEntity(t);

    drawPlayer();
    drawParticles();
    drawHUD();
    drawDeadFlash();

    ctx.restore();
  }

  let last = performance.now();
  function loop(now){
    const dt = clamp((now - last) / 1000, 0, 1/20);
    last = now;

    if (STATE.mode === "play" || STATE.mode === "dead"){
      update(dt);
    }

    render();
    requestAnimationFrame(loop);
  }

  async function boot(){
    STATE.mode = "loading";

    const [a,b,c,d] = await Promise.all([
      loadImage(ASSET_URLS.milkCarton),
      loadImage(ASSET_URLS.milkPhoto),
      loadImage(ASSET_URLS.receipt),
      loadImage(ASSET_URLS.printer)
    ]);

    IMG.milkCarton = a;
    IMG.milkPhoto   = b;
    IMG.receipt     = c;
    IMG.printer     = d;

    STATE.mode = "menu";
    requestAnimationFrame(loop);
  }

  boot();
})();
</script>
</body>
</html>
