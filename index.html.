<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Receipt Run</title>
  <style>
    :root { color-scheme: dark; }
    html, body { margin:0; height:100%; background:#06070a; overflow:hidden; font-family: system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial, sans-serif; }
    canvas { display:block; width:100vw; height:100vh; }

    /* HUD */
    .hud {
      position: fixed; inset: 0; pointer-events: none;
      display:flex; align-items:flex-start; justify-content:space-between;
      padding: 12px; gap: 12px;
      color: rgba(245,245,255,0.92);
      text-shadow: 0 2px 16px rgba(0,0,0,0.55);
      font-size: 14px;
    }
    .panel {
      pointer-events: none;
      background: rgba(10,12,18,0.55);
      border: 1px solid rgba(255,255,255,0.10);
      border-radius: 14px;
      padding: 10px 12px;
      backdrop-filter: blur(10px);
      max-width: 560px;
    }
    .title { font-weight: 850; letter-spacing: 0.4px; }
    .muted { opacity: 0.78; }
    .kbd {
      display:inline-block; padding: 1px 6px; border-radius: 7px;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.06);
      font-weight: 750; font-size: 12px; transform: translateY(-1px);
    }

    /* Controls (touch-friendly) */
    .controls {
      position: fixed; left: 12px; right: 12px; bottom: 12px;
      display:flex; gap: 10px; justify-content: space-between; flex-wrap: wrap;
      pointer-events: auto;
      user-select: none;
    }
    .btn {
      flex: 1 1 140px;
      min-width: 140px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.06);
      color: rgba(245,245,255,0.92);
      padding: 12px 12px;
      font-weight: 800;
      letter-spacing: 0.2px;
      box-shadow: 0 14px 60px rgba(0,0,0,0.35);
      backdrop-filter: blur(10px);
      cursor: pointer;
    }
    .btn:active { transform: translateY(1px); }
    .btn small { display:block; opacity: 0.75; font-weight: 650; margin-top: 2px; }

    /* Overlay */
    .overlay {
      position: fixed; inset: 0; display:flex; align-items:center; justify-content:center;
      padding: 22px; background: rgba(0,0,0,0.35);
      backdrop-filter: blur(10px);
      pointer-events: auto;
    }
    .card {
      width: min(720px, 92vw);
      background: rgba(9,10,16,0.78);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 18px;
      padding: 18px 18px 16px;
      box-shadow: 0 20px 90px rgba(0,0,0,0.55);
      color: rgba(245,245,255,0.92);
    }
    .card h1 { margin: 0 0 10px; font-size: 22px; }
    .card p { margin: 0 0 10px; line-height: 1.45; opacity: 0.88; }
    .row { display:flex; flex-wrap:wrap; gap: 10px; margin-top: 12px; }
    .pill {
      display:inline-flex; align-items:center; gap:8px;
      padding: 8px 10px; border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.06);
      font-weight: 750; font-size: 13px; opacity: 0.92;
    }
    .ok { color: rgba(170,255,200,0.95); }
    .warn { color: rgba(255,220,140,0.95); }
    .bad { color: rgba(255,130,150,0.95); }
  </style>
</head>
<body>
<canvas id="c"></canvas>

<div class="hud">
  <div class="panel">
    <div class="title">Receipt Run <span class="muted">· remember the rules, prep fast, scan clean</span></div>
    <div id="hud1" class="muted">Score: 0 · Streak: 0 · Mult: x1.0 · Lives: 3</div>
    <div id="hud2" class="muted">Speed: 1.0 · Focus: none</div>
  </div>
  <div class="panel muted" style="text-align:right">
    <div>Keys: <span class="kbd">S</span> Scan · <span class="kbd">I</span> ID · <span class="kbd">D</span> Discount · <span class="kbd">B</span> Bag · <span class="kbd">W</span> Weigh · <span class="kbd">R</span> Reject</div>
    <div>Tip: do actions in the “prep zone”, then scan in the scanner gate.</div>
  </div>
</div>

<div class="controls">
  <button class="btn" id="btnScan">SCAN <small>(S)</small></button>
  <button class="btn" id="btnID">ID CHECK <small>(I)</small></button>
  <button class="btn" id="btnDisc">DISCOUNT <small>(D)</small></button>
  <button class="btn" id="btnBag">BAG <small>(B)</small></button>
  <button class="btn" id="btnWeigh">WEIGH <small>(W)</small></button>
  <button class="btn" id="btnReject">REJECT <small>(R)</small></button>
</div>

<div class="overlay" id="overlay">
  <div class="card" id="card">
    <h1>Receipt Run</h1>
    <p>
      Items roll in fast. Each item flashes its “rules” for a moment: <b>18+</b>, <b>Coupon</b>, <b>Fragile</b>, <b>Weigh</b>, or <b>Suspicious</b>.
      Prep the focused item in the prep zone, then scan it in the scanner gate.
    </p>
    <p class="muted">
      Mistakes cost lives. Streaks boost multiplier. Speed ramps up. This is basically panic, but satisfying.
    </p>
    <div class="row">
      <div class="pill ok">Start: click / tap anywhere</div>
      <div class="pill warn">Clues fade quickly</div>
      <div class="pill bad">Wrong prep or late scan = life lost</div>
    </div>
  </div>
</div>

<script>
(() => {
  // ---------- Canvas ----------
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha: false });

  function resize() {
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    canvas.width = Math.floor(innerWidth * dpr);
    canvas.height = Math.floor(innerHeight * dpr);
    canvas.style.width = innerWidth + 'px';
    canvas.style.height = innerHeight + 'px';
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  addEventListener('resize', resize, { passive: true });
  resize();

  // ---------- HUD ----------
  const hud1 = document.getElementById('hud1');
  const hud2 = document.getElementById('hud2');
  const overlay = document.getElementById('overlay');
  const card = document.getElementById('card');

  // ---------- Helpers ----------
  const rand = (a,b) => a + Math.random() * (b - a);
  const clamp = (v,a,b) => Math.max(a, Math.min(b, v));
  const dist2 = (ax,ay,bx,by) => {
    const dx=ax-bx, dy=ay-by;
    return dx*dx + dy*dy;
  };

  // ---------- Game State ----------
  let state = 'menu'; // menu | running | over
  let tPrev = 0;

  let score = 0;
  let streak = 0;
  let mult = 1.0;
  let lives = 3;

  // difficulty / pacing
  let speedScale = 1.0;
  let clueWindow = 0.85;   // seconds clues are visible
  let spawnGap = 150;      // px baseline spacing (lower = harder)
  let beltSpeed = 220;     // px/sec baseline

  const world = {
    items: [],
    nextSpawnX: -200,
    time: 0,
    lastFocusId: null
  };

  // conveyor layout
  function layout() {
    const w = innerWidth, h = innerHeight;
    const beltY = Math.floor(h * 0.64);
    const beltH = Math.max(120, Math.floor(h * 0.18));
    const scannerX = Math.floor(w * 0.72);
    const gateW = 46; // scan window width-ish
    const prepLeft = scannerX - 260;
    const prepRight = scannerX - 70;
    const clueX = Math.floor(w * 0.28);
    return { w, h, beltY, beltH, scannerX, gateW, prepLeft, prepRight, clueX };
  }

  // ---------- Items + Rules ----------
  // Each item has:
  // rules: set of required actions before scanning
  // flags: suspicious means should be rejected instead of scanned
  // scanCount: number of scans required (e.g. "bad barcode" requires 2 scans)
  const RULE = {
    ID: 'ID',
    DISC: 'DISC',
    BAG: 'BAG',
    WEIGH: 'WEIGH',
    REJECT: 'REJECT' // used only as required rule for suspicious items
  };

  const TYPES = [
    { name:'Apple',       base:'produce',  color:'#9be27f', possible:[RULE.WEIGH] },
    { name:'Milk',        base:'normal',   color:'#cfe8ff', possible:[RULE.DISC] },
    { name:'Glass Jar',   base:'fragile',  color:'#a6d4ff', possible:[RULE.BAG] },
    { name:'Wine',        base:'age',      color:'#ffb3c2', possible:[RULE.ID] },
    { name:'Energy',      base:'age',      color:'#ffd27a', possible:[RULE.ID, RULE.DISC] },
    { name:'Cereal',      base:'normal',   color:'#ffeaa8', possible:[RULE.DISC] },
    { name:'Perfume',     base:'fragile',  color:'#d8b3ff', possible:[RULE.BAG, RULE.DISC] },
    { name:'Mystery Box', base:'sus',      color:'#ff7b8f', possible:[RULE.REJECT] }
  ];

  let idCounter = 1;

  function makeItem(spawnX) {
    const t = TYPES[Math.floor(Math.random() * TYPES.length)];
    const rules = new Set();

    // decide required rules
    // suspicious items should be rejected, not scanned
    let suspicious = (t.base === 'sus') || (Math.random() < (0.06 + clamp(speedScale-1,0,1)*0.05));
    if (suspicious) rules.add(RULE.REJECT);

    // regular rules
    // difficulty increases rule count slightly over time
    const difficulty = clamp((score / 1200) + (speedScale - 1) * 0.8, 0, 1);

    // base rule from type
    if (!suspicious && t.possible.length) {
      if (Math.random() < 0.70) rules.add(t.possible[Math.floor(Math.random() * t.possible.length)]);
    }

    // extra chance for second rule
    if (!suspicious && Math.random() < (0.12 + difficulty * 0.25)) {
      const pool = [RULE.ID, RULE.DISC, RULE.BAG, RULE.WEIGH];
      rules.add(pool[Math.floor(Math.random() * pool.length)]);
    }

    // fragile implies bag (more intuitive)
    if (!suspicious && t.base === 'fragile') {
      if (Math.random() < 0.75) rules.add(RULE.BAG);
    }

    // produce implies weigh sometimes
    if (!suspicious && t.base === 'produce') {
      if (Math.random() < 0.80) rules.add(RULE.WEIGH);
    }

    // age items usually need ID
    if (!suspicious && t.base === 'age') {
      if (Math.random() < 0.88) rules.add(RULE.ID);
    }

    // rare “bad barcode” -> needs 2 scans (spicy pressure)
    const needsRescan = !suspicious && Math.random() < (0.06 + difficulty * 0.06);
    const scanCount = needsRescan ? 2 : 1;

    // clue tags shown briefly near clue zone
    const clueTags = [];
    if (rules.has(RULE.ID)) clueTags.push('18+');
    if (rules.has(RULE.DISC)) clueTags.push('Coupon');
    if (rules.has(RULE.BAG)) clueTags.push('Fragile');
    if (rules.has(RULE.WEIGH)) clueTags.push('Weigh');
    if (rules.has(RULE.REJECT)) clueTags.push('Suspicious');
    if (needsRescan) clueTags.push('Barcode?');

    return {
      id: idCounter++,
      typeName: t.name,
      color: t.color,
      x: spawnX,
      laneBob: rand(-10, 10),
      w: rand(82, 102),
      h: rand(42, 52),
      rules,
      suspicious: rules.has(RULE.REJECT),
      scanCount,
      scansDone: 0,
      actionsDone: new Set(),
      clueTags,
      clueShown: false,
      clueT: 0,
      passedScanner: false,
      removed: false,
      // tiny personality wobble
      wiggle: rand(0, Math.PI * 2)
    };
  }

  // ---------- Focus selection ----------
  function getFocusItem(L) {
    // Focus item: nearest to scanner but not passed it yet
    const sx = L.scannerX;
    let best = null;
    let bestX = -Infinity;
    for (const it of world.items) {
      if (it.removed) continue;
      // allow small overshoot still focusable for a brief moment
      if (it.x > sx + 24) continue;
      if (it.x > bestX) { bestX = it.x; best = it; }
    }
    return best;
  }

  // ---------- Actions ----------
  function inPrepZone(it, L) {
    const left = L.prepLeft;
    const right = L.prepRight;
    return it && it.x > left && it.x < right;
  }

  function inScanGate(it, L) {
    const dx = Math.abs(it.x - L.scannerX);
    return dx <= L.gateW;
  }

  function punish(msg) {
    lives -= 1;
    streak = 0;
    mult = 1.0;
    flash(msg, 'bad');
    if (lives <= 0) gameOver();
  }

  function reward(points, msg) {
    score += points;
    streak += 1;
    mult = clamp(1.0 + streak * 0.06, 1, 4.0);
    flash(msg, 'ok');
  }

  // little status text pop
  let toast = { t: 0, text: '', kind: 'muted' };
  function flash(text, kind='muted') {
    toast.t = 1.05;
    toast.text = text;
    toast.kind = kind;
  }

  function doAction(action) {
    if (state !== 'running') return;
    const L = layout();
    const it = getFocusItem(L);

    if (!it) { punish('No item!'); return; }

    // Reject is allowed in scan gate OR prep zone (panic option)
    const okZone = action === RULE.REJECT ? (inPrepZone(it, L) || inScanGate(it, L)) : inPrepZone(it, L);
    if (!okZone) { punish('Too late/early'); return; }

    // Prevent spamming same action
    if (it.actionsDone.has(action) && action !== 'SCAN') {
      punish('Duplicate action');
      return;
    }

    if (action === RULE.ID || action === RULE.DISC || action === RULE.BAG || action === RULE.WEIGH) {
      it.actionsDone.add(action);

      // If action wasn’t required, it’s a mistake (tight, but addictive)
      if (!it.rules.has(action)) {
        punish('Wrong prep');
      } else {
        reward(Math.floor(10 * mult), action === RULE.ID ? 'ID ok' :
               action === RULE.DISC ? 'Discount ok' :
               action === RULE.BAG ? 'Bagged' : 'Weighed');
      }
      return;
    }

    if (action === RULE.REJECT) {
      if (it.suspicious) {
        it.removed = true;
        reward(Math.floor(90 * mult), 'Rejected ✔');
      } else {
        // rejecting a normal item is harsh
        it.removed = true;
        punish('Rejected wrong item');
      }
      return;
    }
  }

  function doScan() {
    if (state !== 'running') return;
    const L = layout();
    const it = getFocusItem(L);

    if (!it) { punish('No item!'); return; }
    if (!inScanGate(it, L)) { punish('Scan timing'); return; }

    // If suspicious item reaches scanner: should have been rejected
    if (it.suspicious) {
      punish('Scanned suspicious item');
      it.removed = true;
      return;
    }

    // Check missing required actions (excluding reject)
    for (const r of it.rules) {
      if (r === RULE.REJECT) continue;
      if (!it.actionsDone.has(r)) {
        punish('Missing prep');
        it.removed = true;
        return;
      }
    }

    it.scansDone += 1;

    if (it.scansDone < it.scanCount) {
      // Needs another scan: tiny reward, but keep pressure
      reward(Math.floor(18 * mult), 'Rescan!');
      return;
    }

    // Successful scan
    it.removed = true;
    const base = 60 + Math.floor((it.rules.size) * 18) + (it.scanCount === 2 ? 20 : 0);
    reward(Math.floor(base * mult), 'Scan ✔');
  }

  // ---------- Input wiring ----------
  function bindBtn(id, fn) {
    const el = document.getElementById(id);
    el.addEventListener('click', (e) => { e.preventDefault(); fn(); }, { passive: false });
    el.addEventListener('pointerdown', (e) => { e.preventDefault(); fn(); }, { passive: false });
  }

  bindBtn('btnScan', doScan);
  bindBtn('btnID',   () => doAction(RULE.ID));
  bindBtn('btnDisc', () => doAction(RULE.DISC));
  bindBtn('btnBag',  () => doAction(RULE.BAG));
  bindBtn('btnWeigh',() => doAction(RULE.WEIGH));
  bindBtn('btnReject',() => doAction(RULE.REJECT));

  addEventListener('keydown', (e) => {
    const k = e.key.toLowerCase();
    if (k === 's') { e.preventDefault(); doScan(); }
    if (k === 'i') { e.preventDefault(); doAction(RULE.ID); }
    if (k === 'd') { e.preventDefault(); doAction(RULE.DISC); }
    if (k === 'b') { e.preventDefault(); doAction(RULE.BAG); }
    if (k === 'w') { e.preventDefault(); doAction(RULE.WEIGH); }
    if (k === 'r') { e.preventDefault(); doAction(RULE.REJECT); }
    if (k === 'enter' && (state === 'menu' || state === 'over')) { start(); }
  });

  // start on any click
  addEventListener('pointerdown', () => {
    if (state === 'menu' || state === 'over') start();
  }, { passive: true });

  // ---------- Start/Reset ----------
  function start() {
    state = 'running';
    overlay.style.display = 'none';

    score = 0;
    streak = 0;
    mult = 1.0;
    lives = 3;

    speedScale = 1.0;
    clueWindow = 0.85;
    spawnGap = 150;
    beltSpeed = 220;

    world.items.length = 0;
    world.time = 0;

    world.nextSpawnX = -220;
    seed();
    toast.t = 0;
    toast.text = '';
  }

  function seed() {
    // pre-fill conveyor
    const L = layout();
    let x = -260;
    for (let i=0;i<6;i++) {
      x -= rand(120, 160);
      world.items.push(makeItem(x));
    }
    world.nextSpawnX = x - 140;
  }

  function gameOver() {
    state = 'over';
    overlay.style.display = 'flex';
    card.innerHTML = `
      <h1>Shift ended.</h1>
      <p>
        <b>Score:</b> ${Math.floor(score)}<br>
        <b>Streak:</b> ${streak}<br>
        <b>Multiplier:</b> x${mult.toFixed(1)}
      </p>
      <p class="muted">Click/tap to restart. Tip: do prep actions early in the prep zone, then scan dead-centre.</p>
      <div class="row">
        <div class="pill ok">Restart: click / tap / Enter</div>
        <div class="pill warn">Clues fade faster as you score more</div>
      </div>
    `;
  }

  // ---------- Update ----------
  function update(dt) {
    const L = layout();
    world.time += dt;

    // ramp difficulty with score
    const targetScale = 1.0 + clamp(score / 2200, 0, 1.2);
    speedScale += (targetScale - speedScale) * 0.05;

    beltSpeed = 220 * speedScale;
    clueWindow = clamp(0.85 - (speedScale - 1) * 0.22, 0.45, 0.90);
    spawnGap = clamp(150 - (speedScale - 1) * 28, 110, 160);

    // move items
    for (const it of world.items) {
      if (it.removed) continue;
      it.wiggle += dt * (1.2 + speedScale * 0.3);
      it.x += beltSpeed * dt;

      // show clue once when crossing clue zone (briefly)
      if (!it.clueShown && it.x >= L.clueX) {
        it.clueShown = true;
        it.clueT = clueWindow;
      }
      if (it.clueT > 0) it.clueT -= dt;

      // if item passes scanner without being removed => missed
      if (!it.passedScanner && it.x > L.scannerX + L.gateW + 24) {
        it.passedScanner = true;

        // suspicious item passing through = huge mistake (you let it through)
        if (!it.removed) {
          if (it.suspicious) punish('Let suspicious through');
          else punish('Missed scan');
          it.removed = true;
        }
      }
    }

    // cleanup removed items
    world.items = world.items.filter(it => it.x < L.w + 220 && !it.removed);

    // spawn new items behind
    const leftBound = -260;
    // ensure we always have enough
    while (world.items.length < 8) {
      world.nextSpawnX = leftBound - rand(spawnGap, spawnGap + 70);
      world.items.unshift(makeItem(world.nextSpawnX));
    }

    // toast timer
    if (toast.t > 0) toast.t -= dt;
  }

  // ---------- Draw ----------
  function draw() {
    const L = layout();
    const w=L.w, h=L.h;

    // background
    ctx.fillStyle = '#06070a';
    ctx.fillRect(0,0,w,h);

    // subtle gradient band
    const g = ctx.createLinearGradient(0, 0, 0, h);
    g.addColorStop(0, '#070914');
    g.addColorStop(1, '#04050a');
    ctx.fillStyle = g;
    ctx.fillRect(0,0,w,h);

    // belt
    const beltTop = L.beltY - L.beltH/2;
    ctx.fillStyle = 'rgba(255,255,255,0.06)';
    roundRect(12, beltTop, w-24, L.beltH, 18, true, false);

    // belt lines
    ctx.strokeStyle = 'rgba(255,255,255,0.07)';
    ctx.lineWidth = 2;
    for (let i=0;i<12;i++) {
      const x = (i* (w/12) + (performance.now()*0.05) % (w/12));
      ctx.beginPath();
      ctx.moveTo(x, beltTop + 14);
      ctx.lineTo(x + 60, beltTop + L.beltH - 14);
      ctx.stroke();
    }

    // scanner gate
    ctx.fillStyle = 'rgba(120,200,255,0.10)';
    roundRect(L.scannerX - L.gateW, beltTop-14, L.gateW*2, L.beltH+28, 12, true, false);
    ctx.strokeStyle = 'rgba(170,220,255,0.30)';
    ctx.lineWidth = 2;
    roundRect(L.scannerX - L.gateW, beltTop-14, L.gateW*2, L.beltH+28, 12, false, true);

    // prep zone
    ctx.strokeStyle = 'rgba(255,255,255,0.12)';
    ctx.setLineDash([6,6]);
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.rect(L.prepLeft, beltTop-10, (L.prepRight - L.prepLeft), L.beltH+20);
    ctx.stroke();
    ctx.setLineDash([]);

    // clue zone marker
    ctx.strokeStyle = 'rgba(255,255,255,0.10)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(L.clueX, beltTop-18);
    ctx.lineTo(L.clueX, beltTop+L.beltH+18);
    ctx.stroke();

    // focus item
    const focus = getFocusItem(L);
    const focusId = focus ? focus.id : null;

    // items
    for (const it of world.items) {
      const iy = L.beltY + it.laneBob + Math.sin(it.wiggle)*4;
      const x = it.x;
      const y = iy;

      // shadow
      ctx.fillStyle = 'rgba(0,0,0,0.35)';
      ctx.beginPath();
      ctx.ellipse(x, y + 22, it.w*0.42, it.h*0.22, 0, 0, Math.PI*2);
      ctx.fill();

      // body
      ctx.fillStyle = it.color;
      roundRect(x - it.w/2, y - it.h/2, it.w, it.h, 12, true, false);

      // outline
      ctx.strokeStyle = 'rgba(10,12,18,0.45)';
      ctx.lineWidth = 2;
      roundRect(x - it.w/2, y - it.h/2, it.w, it.h, 12, false, true);

      // label
      ctx.fillStyle = 'rgba(10,12,18,0.70)';
      ctx.font = '700 12px system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial';
      ctx.textAlign = 'center';
      ctx.fillText(it.typeName, x, y + 4);

      // barcode stripes
      ctx.fillStyle = 'rgba(10,12,18,0.22)';
      for (let k=0;k<10;k++) {
        const bw = (k%3===0) ? 2 : 1;
        ctx.fillRect(x - it.w/2 + 10 + k*6, y + it.h/2 - 10, bw, 8);
      }

      // focus highlight
      if (focusId === it.id) {
        ctx.strokeStyle = 'rgba(255,255,255,0.22)';
        ctx.lineWidth = 3;
        roundRect(x - it.w/2 - 6, y - it.h/2 - 6, it.w+12, it.h+12, 14, false, true);
      }

      // clue tags (brief)
      if (it.clueT > 0) {
        const alpha = clamp(it.clueT / clueWindow, 0, 1);
        drawTags(x, y - it.h/2 - 18, it.clueTags, alpha);
      }

      // progress dots for required rules (only for focus item, and only if you did them)
      if (focusId === it.id) {
        const req = [...it.rules].filter(r => r !== RULE.REJECT);
        const done = req.filter(r => it.actionsDone.has(r)).length;
        const total = Math.max(0, req.length);

        // small indicator under item
        if (total > 0) {
          const baseY = y + it.h/2 + 18;
          const startX = x - (total-1)*10/2;
          for (let i=0;i<total;i++) {
            const on = i < done;
            ctx.fillStyle = on ? 'rgba(180,255,210,0.95)' : 'rgba(255,255,255,0.16)';
            ctx.beginPath();
            ctx.arc(startX + i*10, baseY, 3.4, 0, Math.PI*2);
            ctx.fill();
          }
        }

        // rescan indicator
        if (it.scanCount === 2) {
          ctx.fillStyle = it.scansDone === 0 ? 'rgba(255,220,140,0.9)' : 'rgba(180,255,210,0.9)';
          ctx.font = '800 11px system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial';
          ctx.fillText(it.scansDone === 0 ? 'RESCAN' : '1/2 DONE', x, y - it.h/2 - 6);
        }

        if (it.suspicious) {
          ctx.fillStyle = 'rgba(255,130,150,0.92)';
          ctx.font = '900 11px system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial';
          ctx.fillText('REJECT', x, y - it.h/2 - 6);
        }
      }
    }

    // toast message (top-middle)
    if (toast.t > 0) {
      const a = clamp(toast.t / 1.05, 0, 1);
      ctx.globalAlpha = 0.15 + a*0.85;

      const text = toast.text;
      ctx.font = '900 16px system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial';
      const tw = ctx.measureText(text).width;
      const bx = w/2 - tw/2 - 16;
      const by = Math.max(70, Math.floor(h*0.14));
      const bw = tw + 32;
      const bh = 40;

      ctx.fillStyle = 'rgba(10,12,18,0.65)';
      roundRect(bx, by, bw, bh, 14, true, false);

      const col = toast.kind === 'ok' ? 'rgba(170,255,200,0.95)'
               : toast.kind === 'bad' ? 'rgba(255,130,150,0.95)'
               : 'rgba(245,245,255,0.92)';
      ctx.fillStyle = col;
      ctx.textAlign = 'center';
      ctx.fillText(text, w/2, by + 26);

      ctx.globalAlpha = 1;
    }

    // HUD update
    hud1.textContent = `Score: ${Math.floor(score)} · Streak: ${streak} · Mult: x${mult.toFixed(1)} · Lives: ${lives}`;
    const focusName = focus ? focus.typeName : 'none';
    hud2.textContent = `Speed: ${speedScale.toFixed(2)} · Focus: ${focusName}`;
  }

  function drawTags(x, y, tags, alpha) {
    if (!tags || tags.length === 0) return;

    ctx.save();
    ctx.globalAlpha = alpha * 0.95;
    ctx.font = '800 12px system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial';
    ctx.textAlign = 'left';

    let px = x - 110;
    let py = y;

    for (const t of tags) {
      const w = ctx.measureText(t).width + 18;
      const h = 22;

      const danger = (t === 'Suspicious');
      const warn = (t === '18+' || t === 'Barcode?' || t === 'Weigh');
      const bg = danger ? 'rgba(255,120,140,0.20)' : warn ? 'rgba(255,220,140,0.16)' : 'rgba(170,220,255,0.12)';
      const stroke = danger ? 'rgba(255,120,140,0.35)' : warn ? 'rgba(255,220,140,0.28)' : 'rgba(170,220,255,0.22)';
      const fg = danger ? 'rgba(255,160,175,0.95)' : warn ? 'rgba(255,230,170,0.95)' : 'rgba(210,235,255,0.92)';

      ctx.fillStyle = bg;
      roundRect(px, py, w, h, 999, true, false);
      ctx.strokeStyle = stroke;
      ctx.lineWidth = 1;
      roundRect(px, py, w, h, 999, false, true);

      ctx.fillStyle = fg;
      ctx.fillText(t, px + 9, py + 15);

      px += w + 8;
    }

    ctx.restore();
  }

  function roundRect(x, y, w, h, r, fill, stroke) {
    r = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
    if (fill) ctx.fill();
    if (stroke) ctx.stroke();
  }

  // ---------- Main Loop ----------
  function frame(t) {
    if (!tPrev) tPrev = t;
    const dt = clamp((t - tPrev) / 1000, 0, 0.033);
    tPrev = t;

    if (state === 'running') update(dt);
    draw();

    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);

})();
</script>
</body>
</html>
