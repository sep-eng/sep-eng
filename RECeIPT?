<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" />
  <title>RECeIPT? — Receipt Run</title>
  <style>
    :root{
      --w:160px;
      --h:144px;
      --scale:5;
    }
    html,body{
      height:100%;
      margin:0;
      background:#050505;
      color:#fff;
      font-family:system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial;
      display:flex;
      align-items:center;
      justify-content:center;
    }
    .wrap{
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:10px;
      padding:16px;
    }
    canvas{
      width:calc(var(--w) * var(--scale));
      height:calc(var(--h) * var(--scale));
      border:1px solid rgba(255,255,255,.12);
      border-radius:12px;
      background:#000;
      image-rendering:pixelated;
      image-rendering:crisp-edges;
      box-shadow:0 10px 30px rgba(0,0,0,.5);
      touch-action:none;
    }
    .hint{
      font-size:12px;
      opacity:.75;
      text-align:center;
      max-width:520px;
      line-height:1.35;
    }
    .kbd{
      display:inline-block;
      padding:2px 6px;
      border:1px solid rgba(255,255,255,.25);
      border-bottom-color:rgba(255,255,255,.15);
      border-radius:6px;
      font-size:11px;
      background:rgba(255,255,255,.06);
      margin:0 2px;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <canvas id="c" width="160" height="144"></canvas>
    <div class="hint">
      Move: <span class="kbd">↑</span><span class="kbd">↓</span><span class="kbd">←</span><span class="kbd">→</span>
      · Dash: <span class="kbd">Space</span> · Pause: <span class="kbd">P</span><br/>
      Collect receipts. Dodge audits. Die = restart from Level 1.
    </div>
  </div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');

  // ---------- Basics ----------
  const W = canvas.width, H = canvas.height;
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const rnd = (a,b) => a + Math.random()*(b-a);
  const irnd = (a,b) => Math.floor(rnd(a,b+1));

  // Pixel vibe: draw with solid blocks + tiny details (you can swap for sprites later)
  const COLORS = {
    bg0:"#05060a",
    bg1:"#0a0c12",
    white:"#f5f5f5",
    soft:"#cfd3da",
    neon:"#86efac",
    danger:"#fb7185",
    gold:"#fde047",
    ink:"#111827",
  };

  // ---------- Game State ----------
  const LS_BEST = "receipt_run_best_v1";
  let best = Number(localStorage.getItem(LS_BEST) || 0);

  const state = {
    mode: "menu", // menu | playing | between | dead | paused
    levelIndex: 0,
    levelTimer: 0,
    levelDuration: 0,
    score: 0,
    receipts: 0,
    shake: 0,
    flash: 0,
    t: 0
  };

  // Levels: tweak these to taste
  // duration is seconds; difficulty ramps by speed + spawn rates
  const LEVELS = [
    { name:"Onboarding",      duration: 18, speed: 50,  obstacleRate: 0.75, receiptRate: 1.35, movers: 0.00 },
    { name:"Quarter Close",   duration: 20, speed: 60,  obstacleRate: 0.95, receiptRate: 1.25, movers: 0.10 },
    { name:"Tax Season",      duration: 22, speed: 70,  obstacleRate: 1.10, receiptRate: 1.15, movers: 0.18 },
    { name:"Audit Week",      duration: 24, speed: 82,  obstacleRate: 1.25, receiptRate: 1.05, movers: 0.25 },
    { name:"The Boss Printer",duration: 26, speed: 95,  obstacleRate: 1.35, receiptRate: 1.00, movers: 0.32 },
  ];

  // ---------- Input ----------
  const keys = new Set();
  window.addEventListener('keydown', (e) => {
    const k = e.key.toLowerCase();
    if (["arrowup","arrowdown","arrowleft","arrowright"," ","p","enter"].includes(k) || e.key === " ") e.preventDefault();

    if (k === "p") {
      if (state.mode === "playing") state.mode = "paused";
      else if (state.mode === "paused") state.mode = "playing";
      return;
    }

    if (state.mode === "menu" && (k === "enter" || e.key === " ")) startRun();
    if (state.mode === "dead" && (k === "enter" || e.key === " ")) startRun(); // restart from level 1
    keys.add(e.key);
  });
  window.addEventListener('keyup', (e) => keys.delete(e.key));

  // Tap / click to start/restart (mobile-friendly)
  canvas.addEventListener('pointerdown', () => {
    if (state.mode === "menu" || state.mode === "dead") startRun();
    else if (state.mode === "paused") state.mode = "playing";
  });

  // ---------- Entities ----------
  const player = {
    x: 20, y: H/2,
    w: 10, h: 10,
    vx: 0, vy: 0,
    speed: 95,
    dash: 0, dashCooldown: 0,
    alive: true
  };

  const obstacles = [];
  const receipts = [];
  const particles = [];

  function spawnObstacle(level){
    // Obstacle types: static blocks + some movers later levels
    const type = (Math.random() < level.movers) ? "mover" : "block";
    const size = (type === "mover") ? irnd(10,14) : irnd(10,16);
    obstacles.push({
      type,
      x: W + 10,
      y: irnd(16, H-16),
      w: size,
      h: size,
      vy: (type === "mover") ? rnd(-22, 22) : 0
    });
  }

  function spawnReceipt(level){
    receipts.push({
      x: W + 10,
      y: irnd(14, H-14),
      w: 8,
      h: 8,
      wobble: rnd(0, Math.PI*2)
    });
  }

  function puff(x,y, n=10, color=COLORS.soft){
    for(let i=0;i<n;i++){
      particles.push({
        x,y,
        vx: rnd(-45,45),
        vy: rnd(-55,55),
        life: rnd(0.25, 0.55),
        t: 0,
        color
      });
    }
  }

  function hitShake(power=5){
    state.shake = Math.max(state.shake, power);
    state.flash = 0.12;
  }

  // ---------- Start / Reset ----------
  function resetAll(){
    obstacles.length = 0;
    receipts.length = 0;
    particles.length = 0;

    state.levelIndex = 0;
    state.levelTimer = 0;
    state.score = 0;
    state.receipts = 0;

    player.x = 20;
    player.y = H/2;
    player.vx = 0;
    player.vy = 0;
    player.dash = 0;
    player.dashCooldown = 0;
    player.alive = true;

    state.shake = 0;
    state.flash = 0;
  }

  function beginLevel(i){
    state.levelIndex = i;
    state.levelTimer = 0;
    state.levelDuration = LEVELS[i].duration;
    state.mode = "between";

    // small clear + a few starter receipts
    obstacles.length = 0;
    receipts.length = 0;
    for(let k=0;k<2;k++) spawnReceipt(LEVELS[i]);

    // transition time
    betweenTimer = 0;
  }

  function startRun(){
    resetAll();
    beginLevel(0); // Level 1
  }

  // ---------- Collision ----------
  function aabb(a,b){
    return (a.x < b.x + b.w &&
            a.x + a.w > b.x &&
            a.y < b.y + b.h &&
            a.y + a.h > b.y);
  }

  // ---------- Spawn timers ----------
  let obstAcc = 0;
  let recAcc = 0;
  let betweenTimer = 0;

  // ---------- Update ----------
  function update(dt){
    state.t += dt;

    // screen shake decay + flash decay
    state.shake = Math.max(0, state.shake - dt*12);
    state.flash = Math.max(0, state.flash - dt*3);

    if (state.mode === "menu" || state.mode === "dead") return;
    if (state.mode === "paused") return;

    const level = LEVELS[state.levelIndex];

    if (state.mode === "between"){
      betweenTimer += dt;
      // let player breathe, tiny drift particles
      if (Math.random() < 0.08) particles.push({ x:rnd(0,W), y:rnd(0,H), vx:-rnd(5,15), vy:rnd(-5,5), life:rnd(0.4,0.9), t:0, color:"rgba(255,255,255,.25)" });

      if (betweenTimer > 1.3){
        state.mode = "playing";
        obstAcc = 0;
        recAcc = 0;
      }
      return;
    }

    // ---- Controls + movement ----
    let ax = 0, ay = 0;
    if (keys.has("ArrowLeft")) ax -= 1;
    if (keys.has("ArrowRight")) ax += 1;
    if (keys.has("ArrowUp")) ay -= 1;
    if (keys.has("ArrowDown")) ay += 1;

    const mag = Math.hypot(ax,ay) || 1;
    ax /= mag; ay /= mag;

    // dash
    if (player.dashCooldown > 0) player.dashCooldown -= dt;
    if (player.dash > 0) player.dash -= dt;

    const wantDash = keys.has(" ") || keys.has("Space");
    if (wantDash && player.dashCooldown <= 0 && player.dash <= 0){
      player.dash = 0.15;
      player.dashCooldown = 0.65;
      puff(player.x+player.w/2, player.y+player.h/2, 14, COLORS.neon);
    }

    const speed = player.speed * (player.dash > 0 ? 1.9 : 1.0);
    player.vx = ax * speed;
    player.vy = ay * speed;

    // smooth-ish move
    player.x += player.vx * dt;
    player.y += player.vy * dt;
    player.x = clamp(player.x, 6, W - player.w - 6);
    player.y = clamp(player.y, 8, H - player.h - 8);

    // ---- Spawning ----
    state.levelTimer += dt;

    // obstacle spawn rate (per second)
    obstAcc += dt * level.obstacleRate;
    while (obstAcc >= 1){
      obstAcc -= 1;
      spawnObstacle(level);
    }

    // receipt spawn rate (per second)
    recAcc += dt * level.receiptRate;
    while (recAcc >= 1){
      recAcc -= 1;
      spawnReceipt(level);
    }

    // ---- World scroll ----
    const scroll = level.speed * dt;

    // obstacles
    for (let i=obstacles.length-1;i>=0;i--){
      const o = obstacles[i];
      o.x -= scroll;

      if (o.type === "mover"){
        o.y += o.vy * dt;
        if (o.y < 10 || o.y > H - o.h - 10) o.vy *= -1;
      }

      if (o.x + o.w < -10) obstacles.splice(i,1);
    }

    // receipts
    for (let i=receipts.length-1;i>=0;i--){
      const r = receipts[i];
      r.x -= scroll;
      r.wobble += dt * 8;
      r.y += Math.sin(r.wobble) * dt * 8;

      if (r.x + r.w < -10) receipts.splice(i,1);
    }

    // particles
    for (let i=particles.length-1;i>=0;i--){
      const p = particles[i];
      p.t += dt;
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.vx *= (1 - dt*3.2);
      p.vy *= (1 - dt*3.2);
      if (p.t >= p.life) particles.splice(i,1);
    }

    // ---- Collisions ----
    // receipts: collect
    for (let i=receipts.length-1;i>=0;i--){
      const r = receipts[i];
      if (aabb(player, r)){
        receipts.splice(i,1);
        state.receipts++;
        state.score += 10;
        puff(r.x+r.w/2, r.y+r.h/2, 8, COLORS.gold);
      }
    }

    // obstacles: die (unless dashing, in which case "shave" through with penalty)
    for (let i=obstacles.length-1;i>=0;i--){
      const o = obstacles[i];
      if (aabb(player, o)){
        if (player.dash > 0){
          // dash-through: remove obstacle, smaller reward/penalty
          obstacles.splice(i,1);
          hitShake(3);
          state.score = Math.max(0, state.score - 8);
          puff(o.x+o.w/2, o.y+o.h/2, 12, COLORS.neon);
        } else {
          die();
          return;
        }
      }
    }

    // ---- Level complete ----
    // Score ticks up over time, encourages survival
    state.score += dt * 2.2;

    if (state.levelTimer >= state.levelDuration){
      // next level or win loop
      if (state.levelIndex < LEVELS.length - 1){
        beginLevel(state.levelIndex + 1);
      } else {
        // after final level: keep going in "endless" ramp mode
        // (still counts as polishing; feels good)
        // ramp difficulty softly instead of hard stopping
        LEVELS.push({
          name: "Endless Mode",
          duration: 9999,
          speed: clamp(level.speed + 6, 50, 140),
          obstacleRate: clamp(level.obstacleRate + 0.08, 0.7, 2.0),
          receiptRate: clamp(level.receiptRate, 0.9, 1.4),
          movers: clamp(level.movers + 0.03, 0.0, 0.6)
        });
        beginLevel(state.levelIndex + 1);
      }
    }
  }

  function die(){
    player.alive = false;
    state.mode = "dead";
    hitShake(7);
    puff(player.x+player.w/2, player.y+player.h/2, 22, COLORS.danger);

    // best score
    const finalScore = Math.floor(state.score);
    if (finalScore > best){
      best = finalScore;
      localStorage.setItem(LS_BEST, String(best));
    }

    // IMPORTANT: death means restart from Level 1 when they press start
    // (startRun() already begins at level 0)
  }

  // ---------- Render ----------
  function draw(){
    // camera shake
    const s = state.shake;
    const ox = (s > 0) ? rnd(-s, s) : 0;
    const oy = (s > 0) ? rnd(-s, s) : 0;

    ctx.save();
    ctx.translate(ox, oy);

    // background (subtle gradient blocks)
    const g = ctx.createLinearGradient(0,0,0,H);
    g.addColorStop(0, "#070812");
    g.addColorStop(1, "#050505");
    ctx.fillStyle = g;
    ctx.fillRect(0,0,W,H);

    // floor/grid lines for motion
    ctx.globalAlpha = 0.18;
    ctx.fillStyle = "#ffffff";
    const step = 16;
    const scrollPhase = (state.mode === "playing" ? (state.t*LEVELS[state.levelIndex].speed) : state.t*10) % step;
    for (let x = -step; x < W+step; x += step){
      const xx = x - scrollPhase;
      ctx.fillRect(xx, 0, 1, H);
    }
    ctx.globalAlpha = 1;

    // decorations: "paper trails"
    ctx.globalAlpha = 0.12;
    for (let i=0;i<6;i++){
      ctx.fillStyle = "#ffffff";
      ctx.fillRect((i*30 + (scrollPhase*0.5))%W, 12 + i*20, 10, 1);
    }
    ctx.globalAlpha = 1;

    // receipts
    for (const r of receipts){
      ctx.fillStyle = COLORS.gold;
      ctx.fillRect(r.x, r.y, r.w, r.h);
      ctx.fillStyle = "#111";
      ctx.fillRect(r.x+2, r.y+2, r.w-4, 1);
      ctx.fillRect(r.x+2, r.y+4, r.w-6, 1);
    }

    // obstacles
    for (const o of obstacles){
      if (o.type === "mover"){
        ctx.fillStyle = COLORS.danger;
        ctx.fillRect(o.x, o.y, o.w, o.h);
        ctx.fillStyle = "#111";
        ctx.fillRect(o.x+2, o.y+2, o.w-4, o.h-4);
      } else {
        ctx.fillStyle = "#e5e7eb";
        ctx.fillRect(o.x, o.y, o.w, o.h);
        ctx.fillStyle = "#111827";
        ctx.fillRect(o.x+2, o.y+2, o.w-4, o.h-4);
      }
      // tiny spikes
      ctx.fillStyle = "#000";
      ctx.fillRect(o.x, o.y-1, o.w, 1);
    }

    // player
    ctx.fillStyle = "#86efac";
    ctx.fillRect(player.x, player.y, player.w, player.h);
    ctx.fillStyle = "#062a14";
    ctx.fillRect(player.x+2, player.y+3, 2, 2); // eye
    ctx.fillRect(player.x+6, player.y+3, 2, 2);

    // dash trail
    if (player.dash > 0){
      ctx.globalAlpha = 0.35;
      ctx.fillStyle = COLORS.neon;
      ctx.fillRect(player.x-6, player.y+2, 4, player.h-4);
      ctx.globalAlpha = 1;
    }

    // particles
    for (const p of particles){
      const a = 1 - (p.t / p.life);
      ctx.globalAlpha = clamp(a, 0, 1);
      ctx.fillStyle = p.color;
      ctx.fillRect(p.x, p.y, 2, 2);
    }
    ctx.globalAlpha = 1;

    // HUD
    ctx.fillStyle = "rgba(0,0,0,.55)";
    ctx.fillRect(6, 6, W-12, 16);
    ctx.fillStyle = "#fff";
    ctx.font = "8px system-ui";
    const lvl = state.levelIndex + 1;
    const levelName = LEVELS[state.levelIndex]?.name || "—";
    ctx.fillText(`LVL ${lvl}: ${levelName}`, 10, 17);
    ctx.fillText(`SCORE ${Math.floor(state.score)}`, 10, 28); // slightly below box; intentional overlap vibe
    ctx.fillText(`R ${state.receipts}`, 108, 17);
    ctx.fillText(`BEST ${best}`, 108, 28);

    // overlays
    if (state.mode === "menu"){
      overlayTitle("RECeIPT?", "Receipt Run", "Press Enter / Tap to start");
    }
    if (state.mode === "paused"){
      overlayTitle("PAUSED", "", "Tap or press P to continue");
    }
    if (state.mode === "between"){
      const lvl2 = state.levelIndex + 1;
      overlayTitle(`LEVEL ${lvl2}`, LEVELS[state.levelIndex]?.name || "", "Get ready…");
    }
    if (state.mode === "dead"){
      overlayTitle("YOU GOT AUDITED", `Final score: ${Math.floor(state.score)}`, "Press Enter / Tap to restart (Level 1)");
    }

    // flash on hit
    if (state.flash > 0){
      ctx.globalAlpha = state.flash;
      ctx.fillStyle = "#ffffff";
      ctx.fillRect(0,0,W,H);
      ctx.globalAlpha = 1;
    }

    ctx.restore();
  }

  function overlayTitle(a, b, c){
    ctx.save();
    ctx.fillStyle = "rgba(0,0,0,.72)";
    ctx.fillRect(0,0,W,H);
    ctx.fillStyle = "#fff";
    ctx.textAlign = "center";
    ctx.font = "14px system-ui";
    ctx.fillText(a, W/2, 62);
    ctx.font = "9px system-ui";
    if (b) ctx.fillText(b, W/2, 78);
    ctx.globalAlpha = 0.85;
    ctx.fillText(c, W/2, 98);
    ctx.restore();
  }

  // ---------- Loop ----------
  let last = performance.now();
  function loop(now){
    const dt = clamp((now - last) / 1000, 0, 0.033);
    last = now;

    update(dt);
    draw();
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  // Start in menu
  state.mode = "menu";
})();
</script>
</body>
</html>
